%PDF-1.3
%ºß¬à
3 0 obj
<</Type /Page
/Parent 1 0 R
/Resources 2 0 R
/MediaBox [0 0 595.2799999999999727 841.8899999999999864]
/Contents 4 0 R
>>
endobj
4 0 obj
<<
/Length 4222
>>
stream
0.5670000000000001 w
0 G
BT
/F2 18 Tf
20.6999999999999993 TL
0 g
187.3899999999999295 756.8506299212598378 Td
(IT Skill Test GIC Myanmar) Tj
ET
BT
/F3 12 Tf
13.7999999999999989 TL
0 g
56.6929133858267775 728.5041732283464171 Td
(Duration: 30 Minutes) Tj
ET
BT
/F3 12 Tf
13.7999999999999989 TL
0 g
439.3700787401575099 728.5041732283464171 Td
(Total Questions: 8) Tj
ET
0. G
56.6929133858267775 685.9844881889763428 m
538.5870866141731312 685.9844881889763428 l
S
BT
/F2 12 Tf
13.7999999999999989 TL
0 g
56.6929133858267775 657.6380314960629221 Td
(1.) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
84.9259842519685151 657.6380314960629221 Td
(You are developing a user authentication system. The requirement is to lock a user's) Tj
T* (account after three failed login attempts. Which conditional logic would be most) Tj
T* (appropriate to implement this feature?) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 609.4490551181102092 Td
(A. if \(failedAttempts == 3\) { lockAccount\(\); }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 589.6065354330708033 Td
(B. while \(failedAttempts < 3\) { allowLogin\(\); }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 569.7640157480313974 Td
(C. switch \(failedAttempts\) { case 3: lockAccount\(\); break; }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 549.9214960629921052 Td
(D. if \(failedAttempts >= 3\) { lockAccount\(\); }) Tj
ET
BT
/F2 12 Tf
13.7999999999999989 TL
0 g
56.6929133858267775 515.9057480314959321 Td
(2.) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
84.9259842519685151 515.9057480314959321 Td
(In a temperature monitoring system for a industrial freezer, you need to trigger an) Tj
T* (alert if the temperature rises above -5°C or falls below -20°C. Which conditional) Tj
T* (statement would be most appropriate?) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 467.716771653543276 Td
(A. if \(temperature > -5 || temperature < -20\) { triggerAlert\(\); }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 447.8742519685038701 Td
(B. if \(temperature > -5 && temperature < -20\) { triggerAlert\(\); }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 428.0317322834645211 Td
(C. if \(temperature <= -5 || temperature >= -20\) { triggerAlert\(\); }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 408.1892125984251152 Td
(D. switch \(temperature\) { case > -5: case < -20: triggerAlert\(\); break; }) Tj
ET
BT
/F2 12 Tf
13.7999999999999989 TL
0 g
56.6929133858267775 374.1734645669290558 Td
(3.) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
84.9259842519685151 374.1734645669290558 Td
(You're implementing a simple state machine for a traffic light. The light should change) Tj
T* (from Green to Yellow, Yellow to Red, and Red back to Green. Which control structure) Tj
T* (would be most appropriate for this cyclic behavior?) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 325.9844881889763428 Td
(A. if \(currentState == GREEN\) { nextState = YELLOW; } else if \(currentState ==) Tj
T* (YELLOW\) { nextState = RED; } else { nextState = GREEN; }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 291.9687401574802834 Td
(B. while \(true\) { if \(currentState == GREEN\) nextState = YELLOW; else if) Tj
T* (\(currentState == YELLOW\) nextState = RED; else nextState = GREEN; }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 257.952992125984224 Td
(C. switch \(currentState\) { case GREEN: nextState = YELLOW; break; case YELLOW:) Tj
T* (nextState = RED; break; case RED: nextState = GREEN; break; }) Tj
ET
BT
/F1 12 Tf
13.7999999999999989 TL
0 g
85.0393700787401627 223.9372440944881646 Td
(D. for \(int i = 0; i < 3; i++\) { if \(i == 0\) nextState = YELLOW; else if \(i == 1\) nextState =) Tj
T* (RED; else nextState = GREEN; }) Tj
ET
0. G
56.6929133858267775 70.8661417322834666 m
538.5870866141731312 70.8661417322834666 l
S
BT
/F3 10 Tf
11.5 TL
0 g
164.6899999999999125 56.6929133858268415 Td
(© 2025 Global Innovation Consulting.Inc, All rights reserved.) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
281.9399999999999977 28.3464566929134207 Td
(Page 1) Tj
ET
endstream
endobj
5 0 obj
<</Type /Page
/Parent 1 0 R
/Resources 2 0 R
/MediaBox [0 0 595.2799999999999727 841.8899999999999864]
/Contents 6 0 R
>>
endobj
6 0 obj
<<
/Length 5251
>>
stream
0.5670000000000001 w
0. G
BT
/F2 10 Tf
11.5 TL
0 g
56.6929133858267775 785.1970866141732586 Td
(4.) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
80.2204724409448886 785.1970866141732586 Td
(In a file processing application, you need to read lines from a file until you encounter an empty line or) Tj
T* (reach the end of the file. Which loop structure would be most suitable for this task?) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 751.1813385826771992 Td
(A. for \(String line = reader.readLine\(\); line != null; line = reader.readLine\(\)\) { processLine\(line\); }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 731.3388188976377933 Td
(B. while \(\(line = reader.readLine\(\)\) != null && !line.isEmpty\(\)\) { processLine\(line\); }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 711.4962992125983874 Td
(C. do { line = reader.readLine\(\); processLine\(line\); } while \(line != null\);) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 691.6537795275589815 Td
(D. for \(String line : reader.readLines\(\)\) { if \(line.isEmpty\(\)\) break; processLine\(line\); }) Tj
ET
BT
/F2 10 Tf
11.5 TL
0 g
56.6929133858267775 657.6380314960629221 Td
(5.) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
80.2204724409448886 657.6380314960629221 Td
(You're developing a grading system that assigns letter grades based on numerical scores. The grading) Tj
T* (scale is: A \(90-100\), B \(80-89\), C \(70-79\), D \(60-69\), F \(0-59\). Which conditional structure would be) Tj
T* (most appropriate for this task?) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 609.4490551181102092 Td
(A. if \(score >= 90\) grade = 'A'; else if \(score >= 80\) grade = 'B'; else if \(score >= 70\) grade = 'C'; else if) Tj
T* (\(score >= 60\) grade = 'D'; else grade = 'F';) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 575.4333070866141497 Td
(B. switch \(score / 10\) { case 10: case 9: grade = 'A'; break; case 8: grade = 'B'; break; case 7: grade =) Tj
T* ('C'; break; case 6: grade = 'D'; break; default: grade = 'F'; }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 541.4175590551180903 Td
(C. grade = \(score >= 90\) ? 'A' : \(score >= 80\) ? 'B' : \(score >= 70\) ? 'C' : \(score >= 60\) ? 'D' : 'F';) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 521.5750393700786844 Td
(D. while \(score >= 60\) { if \(score >= 90\) { grade = 'A'; break; } if \(score >= 80\) { grade = 'B'; break; } if) Tj
T* (\(score >= 70\) { grade = 'C'; break; } grade = 'D'; break; } if \(grade == null\) grade = 'F';) Tj
ET
BT
/F2 10 Tf
11.5 TL
0 g
56.6929133858267775 473.3860629921259147 Td
(6.) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
80.2204724409448886 473.3860629921259147 Td
(In a web application, you need to validate user input for a username. The username must be between 3) Tj
T* (and 20 characters long and contain only letters, numbers, and underscores. Which conditional) Tj
T* (statement would best implement this validation?) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 425.1970866141731449 Td
(A. if \(username.length\(\) >= 3 && username.length\(\) <= 20 && username.matches\("^[a-zA-Z0-9_]+$"\)\) {) Tj
T* (/* valid */ } else { /* invalid */ }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 391.1813385826770855 Td
(B. if \(username.length\(\) > 2 || username.length\(\) < 21 && username.matches\("\\w+"\)\) { /* valid */ } else {) Tj
T* (/* invalid */ }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 357.1655905511810261 Td
(C. switch \(username.length\(\)\) { case 3: case 4: /* ... */ case 20: if) Tj
T* (\(username.matches\("^[a-zA-Z0-9_]+$"\)\) { /* valid */ } break; default: /* invalid */ }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 323.1498425196849666 Td
(D. while \(username.length\(\) >= 3 && username.length\(\) <= 20\) { if) Tj
T* (\(username.matches\("^[a-zA-Z0-9_]+$"\)\) { /* valid */ break; } else { /* invalid */ break; } }) Tj
ET
BT
/F2 10 Tf
11.5 TL
0 g
56.6929133858267775 274.9608661417322537 Td
(7.) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
80.2204724409448886 274.9608661417322537 Td
(You're developing a method to calculate the factorial of a number. Which implementation would be most) Tj
T* (efficient and appropriate for numbers up to 20?) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 240.9451181102361943 Td
(A. public static long factorial\(int n\) { if \(n <= 1\) return 1; else return n * factorial\(n - 1\); }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 221.1025984251967884 Td
(B. public static long factorial\(int n\) { long result = 1; for \(int i = 2; i <= n; i++\) result *= i; return result; }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 201.2600787401573825 Td
(C. public static long factorial\(int n\) { return IntStream.rangeClosed\(1, n\).reduce\(1, \(a, b\) -> a * b\); }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 181.4175590551179766 Td
(D. public static long factorial\(int n\) { return LongStream.rangeClosed\(1, n\).reduce\(1, \(a, b\) -> a * b\); }) Tj
ET
0. G
56.6929133858267775 70.8661417322834666 m
538.5870866141731312 70.8661417322834666 l
S
BT
/F3 10 Tf
11.5 TL
0 g
164.6899999999999125 56.6929133858268415 Td
(© 2025 Global Innovation Consulting.Inc, All rights reserved.) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
281.9399999999999977 28.3464566929134207 Td
(Page 2) Tj
ET
endstream
endobj
7 0 obj
<</Type /Page
/Parent 1 0 R
/Resources 2 0 R
/MediaBox [0 0 595.2799999999999727 841.8899999999999864]
/Contents 8 0 R
>>
endobj
8 0 obj
<<
/Length 1963
>>
stream
0.5670000000000001 w
0. G
BT
/F2 10 Tf
11.5 TL
0 g
56.6929133858267775 785.1970866141732586 Td
(8.) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
80.2204724409448886 785.1970866141732586 Td
(You are developing a Java application for a library management system. The system needs to) Tj
T* (categorize books based on their age and condition. Books older than 10 years are considered 'Vintage',) Tj
T* (books between 5 and 10 years old are 'Standard', and books less than 5 years old are 'New'.) Tj
T* (Additionally, if a book's condition is 'Poor', it should be marked for 'Restoration' regardless of its age.) Tj
T* (Which conditional logic structure would be most appropriate for this categorization?) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 708.6616535433070112 Td
(A. if \(bookAge > 10\) { category = "Vintage"; } else if \(bookAge > 5\) { category = "Standard"; } else {) Tj
T* (category = "New"; }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 674.6459055118109518 Td
(B. switch \(bookAge\) { case > 10: category = "Vintage"; break; case > 5: category = "Standard"; break;) Tj
T* (default: category = "New"; }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 640.6301574803148924 Td
(C. if \(condition.equals\("Poor"\)\) { category = "Restoration"; } else if \(bookAge > 10\) { category =) Tj
T* ("Vintage"; } else if \(bookAge > 5\) { category = "Standard"; } else { category = "New"; }) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
85.0393700787401627 606.614409448818833 Td
(D. while \(bookAge > 0\) { if \(bookAge > 10\) { category = "Vintage"; } else if \(bookAge > 5\) { category =) Tj
T* ("Standard"; } else { category = "New"; } break; }) Tj
ET
0. G
56.6929133858267775 70.8661417322834666 m
538.5870866141731312 70.8661417322834666 l
S
BT
/F3 10 Tf
11.5 TL
0 g
164.6899999999999125 56.6929133858268415 Td
(© 2025 Global Innovation Consulting.Inc, All rights reserved.) Tj
ET
BT
/F1 10 Tf
11.5 TL
0 g
281.9399999999999977 28.3464566929134207 Td
(Page 3) Tj
ET
endstream
endobj
1 0 obj
<</Type /Pages
/Kids [3 0 R 5 0 R 7 0 R ]
/Count 3
>>
endobj
9 0 obj
<<
/Type /Font
/BaseFont /Helvetica
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
10 0 obj
<<
/Type /Font
/BaseFont /Helvetica-Bold
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
11 0 obj
<<
/Type /Font
/BaseFont /Helvetica-Oblique
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
12 0 obj
<<
/Type /Font
/BaseFont /Helvetica-BoldOblique
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
13 0 obj
<<
/Type /Font
/BaseFont /Courier
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
14 0 obj
<<
/Type /Font
/BaseFont /Courier-Bold
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
15 0 obj
<<
/Type /Font
/BaseFont /Courier-Oblique
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
16 0 obj
<<
/Type /Font
/BaseFont /Courier-BoldOblique
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
17 0 obj
<<
/Type /Font
/BaseFont /Times-Roman
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
18 0 obj
<<
/Type /Font
/BaseFont /Times-Bold
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
19 0 obj
<<
/Type /Font
/BaseFont /Times-Italic
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
20 0 obj
<<
/Type /Font
/BaseFont /Times-BoldItalic
/Subtype /Type1
/Encoding /WinAnsiEncoding
/FirstChar 32
/LastChar 255
>>
endobj
21 0 obj
<<
/Type /Font
/BaseFont /ZapfDingbats
/Subtype /Type1
/FirstChar 32
/LastChar 255
>>
endobj
22 0 obj
<<
/Type /Font
/BaseFont /Symbol
/Subtype /Type1
/FirstChar 32
/LastChar 255
>>
endobj
2 0 obj
<<
/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]
/Font <<
/F1 9 0 R
/F2 10 0 R
/F3 11 0 R
/F4 12 0 R
/F5 13 0 R
/F6 14 0 R
/F7 15 0 R
/F8 16 0 R
/F9 17 0 R
/F10 18 0 R
/F11 19 0 R
/F12 20 0 R
/F13 21 0 R
/F14 22 0 R
>>
/XObject <<
>>
>>
endobj
23 0 obj
<<
/Producer (jsPDF 3.0.2)
/CreationDate (D:20250930104344+06'30')
>>
endobj
24 0 obj
<<
/Type /Catalog
/Pages 1 0 R
/OpenAction [3 0 R /FitH null]
/PageLayout /OneColumn
>>
endobj
xref
0 25
0000000000 65535 f 
0000012018 00000 n 
0000013851 00000 n 
0000000015 00000 n 
0000000152 00000 n 
0000004426 00000 n 
0000004563 00000 n 
0000009866 00000 n 
0000010003 00000 n 
0000012087 00000 n 
0000012212 00000 n 
0000012343 00000 n 
0000012477 00000 n 
0000012615 00000 n 
0000012739 00000 n 
0000012868 00000 n 
0000013000 00000 n 
0000013136 00000 n 
0000013264 00000 n 
0000013391 00000 n 
0000013520 00000 n 
0000013653 00000 n 
0000013755 00000 n 
0000014103 00000 n 
0000014189 00000 n 
trailer
<<
/Size 25
/Root 24 0 R
/Info 23 0 R
/ID [ <D4897DFCFE7D0663730D38E91FFE255F> <D4897DFCFE7D0663730D38E91FFE255F> ]
>>
startxref
14293
%%EOF